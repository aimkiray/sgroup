### 快速排序在生活中的应用

想象一个场景：桌子上有8本书，这些书的高度各不相同。身为伪处女座，咱想把这些书按从高到低的顺序摆在书架上，请务必帮咱想一个可靠的方法！

- 先把所有的书放到书架上，依次比较相邻书的高度（从左至右依次取名1号~8号，比较1号和2号的高度，若2号比1号高，则交换两者位置，1号继续跟3号比较；若1号比2号高，则让2号跟3号比较。），直到最右边。这时最右边的书就是最低的书，重复上述过程即可完成排序。

这是冒泡排序法

- 先随便选一本书，然后拿这本书跟其他书比较，高的放左边，低的放右边，完成后以最先选中的书为界限把所有书分成2个部分；分别对每部分重复上述操作后划分为4部分；以此类推，直到每部分只有一本书，排序达成。

这是快速排序法，采用了分治的思想，分治法（Divide and conquer）用来将一个序列（list）分为两个子序列（sub-lists）。每次操作的对象比前一次少一半还多，速度明显优于第一种。

步骤为：

1. 从数列中挑出一个元素，称为"基准"（pivot），
2. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。
3. 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。

递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。

那么就决定是你了！回到现实，咱这里有个数组需要排序，那么如何将此方法用Java实现呢？

快速排序最早由东尼·霍尔在1962提出。在平均状况下，排序n个项目要Ο(N*logN)次比较。在最坏状况下则需要`O`次比较，但这种状况并不常见。




先把所有书放到书架上，抽出最左边的书，保留空位，然后从右到左依次跟这本书比较高度（从左至右依次取名1号~8号，比较1号和8号的高度，若8号比1号高，则将8号书移到1号空出的位置；然后1号继续去和7号比较，若7号比8号低，则将7号移动到8号的位置上，以此类推）